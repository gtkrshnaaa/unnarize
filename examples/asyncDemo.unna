// Async/Await Demo for Unnarize language
// This demo showcases:
// 1 Declaring async functions
// 2 Launching async tasks that return a Future
// 3 Using await to get the resolved value
// 4 Observing Future values in print (formatted as [future pending/done])

print "=== ASYNC/AWAIT DEMO ===";

async function computeSum(n) {
    var i = 0;
    var sum = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

async function greetLater(name) {
    // Some fake work
    var k = 0;
    while (k < 200000) { k = k + 1; }
    return "Hello, " + name + "!";
}

print "Launching async tasks...";
var f1 = computeSum(500000);
var f2 = greetLater("Async Unnarize");

// Futures can be printed (they will show pending/done state)
print f1;
print f2;

print "Waiting for results using await...";
var sum = await f1;
var greet = await f2;

print "Results:";
print "sum = " + sum;
print greet;

// Launch and await inline
print "Inline await call:";
print await computeSum(10);

// ---------------------------------------------
// Advanced patterns
// ---------------------------------------------

// 1 Compose multiple async computations and combine results
async function composeSums(a, b) {
    var fa = computeSum(a);
    var fb = computeSum(b);
    var av = await fa;
    var bv = await fb;
    return av + bv;
}

print "Composed result (sum(10000)+sum(20000)):";
print await composeSums(10000, 20000);

// 2 Launch a batch of async tasks and await them in a loop
function launchBatch(n) {
    var futures = array();
    var i = 0;
    while (i < n) {
        // Vary workload a bit
        push(futures, computeSum(10000 + i * 200));
        i = i + 1;
    }
    return futures;
}

var batch = launchBatch(5);
print "Batch launched (array of Futures):";
print batch; // shows compact descriptor

// Sequentially await each future and accumulate
var total = 0;
var idx = 0;
while (idx < length(batch)) {
    var val = await batch[idx];
    total = total + val;
    idx = idx + 1;
}
print "Accumulated total from batch = " + total;

// 3 Futures inside a map and retrieving results
function makeFutureMap() {
    var m = map();
    m["fast"] = computeSum(1000);
    m["slow"] = computeSum(50000);
    return m;
}

var fMap = makeFutureMap();
print "Map of Futures:";
print fMap; // prints compact map descriptor
var fastVal = await fMap["fast"];
var slowVal = await fMap["slow"];
print "fast=" + fastVal + ", slow=" + slowVal;

// 4 Future identity (== compares the same underlying future)
var fx = computeSum(12345);
var aliasFx = fx; // same future reference
var fy = computeSum(12345); // different future
print "fx == aliasFx? " + (fx == aliasFx);
print "fx == fy? " + (fx == fy);
// Ensure we eventually await to realize work
await fx; await fy;

print "=== END ASYNC/AWAIT DEMO ===";
