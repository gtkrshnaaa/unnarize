// Timer plugin benchmark demo
// Tests loop performance of Unnarize interpreter

// Load timer plugin
loadextern("timerLib.so");

print("=== UNNARIZE LOOP PERFORMANCE BENCHMARK ===");
print("");

// Test 1: Simple counting loop
print("Test 1: Simple counting loop");
timerStart();
var count = 0;
for (var i = 0; i < 1000000; i = i + 1) {
    count = count + 1;
}
var elapsedTime1 = timerElapsed();
print("1 million simple increments: " + elapsedTime1 + "ms");
print("Rate: " + (1000000 / elapsedTime1 * 1000) + " ops/second");
print("");

// Test 2: Arithmetic operations in loop
print("Test 2: Arithmetic operations in loop");
timerStart();
var sum = 0;
for (var i = 0; i < 500000; i = i + 1) {
    sum = sum + i * 2 + 1;
}
var elapsedTime2 = timerElapsed();
print("500k arithmetic operations: " + elapsedTime2 + "ms");
print("Rate: " + (500000 / elapsedTime2 * 1000) + " ops/second");
print("Final sum: " + sum);
print("");

// Test 3: Variable assignments
print("Test 3: Variable assignments");
timerStart();
var a = 0;
var b = 0;
var c = 0;
for (var i = 0; i < 300000; i = i + 1) {
    a = i;
    b = a + 1;
    c = b * 2;
}
var elapsedTime3 = timerElapsed();
print("300k variable assignments: " + elapsedTime3 + "ms");
print("Rate: " + (300000 / elapsedTime3 * 1000) + " ops/second");
print("Final values: a=" + a + ", b=" + b + ", c=" + c);
print("");

// Test 4: Nested loops
print("Test 4: Nested loops (1000x1000)");
timerStart();
var nestedCount = 0;
for (var i = 0; i < 1000; i = i + 1) {
    for (var j = 0; j < 1000; j = j + 1) {
        nestedCount = nestedCount + 1;
    }
}
var elapsedTime4 = timerElapsed();
print("1 million nested loop iterations: " + elapsedTime4 + "ms");
print("Rate: " + (1000000 / elapsedTime4 * 1000) + " ops/second");
print("Final count: " + nestedCount);
print("");

// Test 5: Function calls in loop
function simpleAdd(x, y) {
    return x + y;
}

print("Test 5: Function calls in loop");
timerStart();
var funcResult = 0;
for (var i = 0; i < 100000; i = i + 1) {
    funcResult = simpleAdd(i, 1);
}
var elapsedTime5 = timerElapsed();
print("100k function calls: " + elapsedTime5 + "ms");
print("Rate: " + (100000 / elapsedTime5 * 1000) + " ops/second");
print("Final result: " + funcResult);
print("");

// Test 6: String operations
print("Test 6: String concatenations");
timerStart();
var str = "";
for (var i = 0; i < 10000; i = i + 1) {
    if (i % 1000 == 0) {
        str = str + "x";
    }
}
var elapsedTime6 = timerElapsed();
print("10k string operations: " + elapsedTime6 + "ms");
print("Rate: " + (10000 / elapsedTime6 * 1000) + " ops/second");
print("Final string length: " + str);
print("");

// Test 7: High precision timing test
print("Test 7: High precision timing (microseconds)");
timerStart();
var microCount = 0;
for (var i = 0; i < 50000; i = i + 1) {
    microCount = microCount + i;
}
var elapsedMicros = timerElapsedMicros();
print("50k operations: " + elapsedMicros + " microseconds");
print("Rate: " + (50000 / elapsedMicros * 1000000) + " ops/second");
print("");

// Summary
print("=== PERFORMANCE SUMMARY ===");
print("Simple loops: " + (1000000 / elapsedTime1 * 1000) + " ops/sec");
print("Arithmetic: " + (500000 / elapsedTime2 * 1000) + " ops/sec");
print("Assignments: " + (300000 / elapsedTime3 * 1000) + " ops/sec");
print("Nested loops: " + (1000000 / elapsedTime4 * 1000) + " ops/sec");
print("Function calls: " + (100000 / elapsedTime5 * 1000) + " ops/sec");
print("String ops: " + (10000 / elapsedTime6 * 1000) + " ops/sec");
print("");

// Calculate average performance
var totalOps = 1000000 + 500000 + 300000 + 1000000 + 100000 + 10000;
var totalTime = elapsedTime1 + elapsedTime2 + elapsedTime3 + elapsedTime4 + elapsedTime5 + elapsedTime6;
var avgRate = totalOps / totalTime * 1000;

print("Overall average: " + avgRate + " operations per second");
print("That's approximately " + (avgRate / 1000000) + " million ops/sec");
print("");
print("=== END BENCHMARK ===");
