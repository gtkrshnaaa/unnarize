// ==========================================
// 03_functions.unna
// Functions, Recursion, and Closures
// ==========================================

print("=== 1. Basic Functions ===");

function greet(name) {
    return "Hello, " + name + "!";
}

print(greet("Developer"));

print("");
print("=== 2. Recursion ===");

function factorial(n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}

var num = 5;
print("Factorial of " + num + " is " + factorial(num));

print("");
print("=== 3. Closures / Scope ===");

function makeCounter(start) {
    var count = start;
    // Note: Unnarize functions capture scope where defined
    // We can simulate method-like behavior if we had classes, 
    // but here we just show local scope persistence if returned (if supported)
    // or just nested access.
    

    function logic() {
        print("Function called.");
    }
    
    // Call inner function
    logic();
}

makeCounter(100);

var globalVar = "I am global";
function checkScope() {
    print("Inside function accessing global: " + globalVar);
}
checkScope();

// Higher order concepts (simulated via recursion or simple logic)
function fib(n) {
    if (n < 2) return n;
    return fib(n - 1) + fib(n - 2);
}

// print("Fibonacci(10): " + fib(10)); // Commented out to prevent stack overflow on aggressive optimizations or debug builds
print("Fibonacci(5): " + fib(5));

print("");
print("=== End of Functions ===");
